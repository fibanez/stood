//! Streaming support for AWS Bedrock responses.
//!
//! This module provides comprehensive streaming capabilities following the Python reference
//! implementation patterns. It handles real-time processing of model responses, tool execution
//! during streaming, and error recovery mechanisms.
//!
//! Key components:
//! - `StreamEvent`: Rust equivalent of Python's streaming event types
//! - `StreamProcessor`: Process AWS SDK streams into typed events  
//! - `StreamingMessage`: Incremental message building from stream chunks
//! - `StreamConfig`: Configuration for streaming behavior

use futures::Stream;
use serde::{Deserialize, Serialize};
use tokio::sync::mpsc;

use crate::{
    types::{ContentBlock, Message, MessageRole, TokenUsage},
    Result, StoodError,
};

/// Usage information for token consumption
pub use crate::types::TokenUsage as Usage;

impl Default for TokenUsage {
    fn default() -> Self {
        Self {
            input_tokens: 0,
            output_tokens: 0,
            total_tokens: 0,
        }
    }
}

/// Performance metrics for model interactions
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct Metrics {
    /// Latency of the model request in milliseconds
    pub latency_ms: u64,
}

impl Default for Metrics {
    fn default() -> Self {
        Self { latency_ms: 0 }
    }
}

/// Reason for the model ending its response generation
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "snake_case")]
pub enum StopReason {
    /// Content was filtered due to policy violation
    ContentFiltered,
    /// Normal completion of the response
    EndTurn,
    /// Guardrail system intervened
    GuardrailIntervened,
    /// Maximum token limit reached
    MaxTokens,
    /// Stop sequence encountered
    StopSequence,
    /// Model requested to use a tool
    ToolUse,
}

/// Event signaling the start of a message in a streaming response
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct MessageStartEvent {
    /// The role of the message sender (e.g., "assistant", "user")
    pub role: MessageRole,
}

/// Information about a content block being started
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ContentBlockStart {
    /// Text content block starting
    Text,
    /// Tool use content block starting  
    ToolUse {
        /// Unique identifier for this tool call
        tool_use_id: String,
        /// Name of the tool being called
        name: String,
    },
}

/// Event signaling the start of a content block in a streaming response
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct ContentBlockStartEvent {
    /// Index of the content block within the message
    pub content_block_index: Option<u32>,
    /// Information about the content block being started
    pub start: ContentBlockStart,
}

/// Text content delta in a streaming response
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct ContentBlockDeltaText {
    /// The text fragment being streamed
    pub text: String,
}

/// Tool use input delta in a streaming response
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct ContentBlockDeltaToolUse {
    /// The tool input fragment being streamed
    pub input: String,
}

/// Delta for reasoning content block in a streaming response
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct ReasoningContentBlockDelta {
    /// The content in the reasoning that was encrypted by the model provider for safety reasons
    pub redacted_content: Option<Vec<u8>>,
    /// A token that verifies that the reasoning text was generated by the model
    pub signature: Option<String>,
    /// The reasoning that the model used to return the output
    pub text: Option<String>,
}

/// A block of content in a streaming response
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ContentBlockDelta {
    /// Contains content regarding the reasoning that is carried out by the model
    ReasoningContent(ReasoningContentBlockDelta),
    /// Text fragment being streamed
    Text(ContentBlockDeltaText),
    /// Tool use input fragment being streamed
    ToolUse(ContentBlockDeltaToolUse),
}

/// Event containing a delta update for a content block in a streaming response
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct ContentBlockDeltaEvent {
    /// Index of the content block within the message
    pub content_block_index: Option<u32>,
    /// The incremental content update for the content block
    pub delta: ContentBlockDelta,
}

/// Event signaling the end of a content block in a streaming response
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct ContentBlockStopEvent {
    /// Index of the content block within the message
    pub content_block_index: Option<u32>,
}

/// Event signaling the end of a message in a streaming response
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct MessageStopEvent {
    /// Additional fields to include in model response
    pub additional_model_response_fields: Option<serde_json::Value>,
    /// The reason why the model stopped generating content
    pub stop_reason: StopReason,
}

/// Event containing metadata about the streaming response
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct MetadataEvent {
    /// Performance metrics related to the model invocation
    pub metrics: Metrics,
    /// Trace information for debugging and monitoring
    pub trace: Option<serde_json::Value>,
    /// Resource usage information for the model invocation
    pub usage: Usage,
}

/// Base event for exceptions in a streaming response
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct ExceptionEvent {
    /// The error message describing what went wrong
    pub message: String,
}

/// Event for model streaming errors
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct ModelStreamErrorEvent {
    /// The error message describing what went wrong
    pub message: String,
    /// The original error message from the model provider
    pub original_message: String,
    /// The HTTP status code returned by the model provider
    pub original_status_code: u16,
}

/// Event for redacting content
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct RedactContentEvent {
    /// The string to overwrite the users input with
    pub redact_user_content_message: Option<String>,
    /// The string to overwrite the assistants output with
    pub redact_assistant_content_message: Option<String>,
}

/// The messages output stream - core streaming event type
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum StreamEvent {
    /// Delta content for a content block
    ContentBlockDelta(ContentBlockDeltaEvent),
    /// Start of a content block
    ContentBlockStart(ContentBlockStartEvent),
    /// End of a content block
    ContentBlockStop(ContentBlockStopEvent),
    /// Internal server error information
    InternalServerException(ExceptionEvent),
    /// Start of a message
    MessageStart(MessageStartEvent),
    /// End of a message
    MessageStop(MessageStopEvent),
    /// Metadata about the streaming response
    Metadata(MetadataEvent),
    /// Content redaction information
    RedactContent(RedactContentEvent),
    /// Model streaming error information
    ModelStreamErrorException(ModelStreamErrorEvent),
    /// Service unavailable error information
    ServiceUnavailableException(ExceptionEvent),
    /// Throttling error information
    ThrottlingException(ExceptionEvent),
    /// Validation error information
    ValidationException(ExceptionEvent),
}

/// Configuration for streaming behavior
#[derive(Debug, Clone)]
pub struct StreamConfig {
    /// Whether streaming is enabled
    pub enabled: bool,
    /// Buffer size for streaming events
    pub buffer_size: usize,
    /// Timeout for stream operations
    pub timeout: std::time::Duration,
    /// Whether to enable real-time tool execution during streaming
    pub enable_tool_streaming: bool,
}

impl Default for StreamConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            buffer_size: 100,
            timeout: std::time::Duration::from_secs(30),
            enable_tool_streaming: true,
        }
    }
}

/// State for building a message incrementally from stream events
#[derive(Debug, Clone)]
pub struct StreamingMessage {
    /// The message being built
    pub message: Message,
    /// Current text being accumulated
    current_text: String,
    /// Current tool use being built
    current_tool_use: Option<CurrentToolUse>,
    /// Current reasoning text being accumulated
    current_reasoning_text: String,
    /// Current signature being accumulated
    current_signature: String,
    /// Whether the message is complete
    pub is_complete: bool,
    /// Stop reason for the message
    pub stop_reason: Option<StopReason>,
    /// Token usage information
    pub token_usage: Option<Usage>,
}

/// Tool use being built during streaming
#[derive(Debug, Clone)]
struct CurrentToolUse {
    /// Tool use ID
    tool_use_id: String,
    /// Tool name
    name: String,
    /// Input being accumulated
    input: String,
}

impl StreamingMessage {
    /// Create a new streaming message with the given role
    pub fn new(role: MessageRole) -> Self {
        Self {
            message: Message::new(role, vec![]),
            current_text: String::new(),
            current_tool_use: None,
            current_reasoning_text: String::new(),
            current_signature: String::new(),
            is_complete: false,
            stop_reason: None,
            token_usage: None,
        }
    }

    /// Process a stream event and update the message
    pub fn process_event(&mut self, event: StreamEvent) -> Result<()> {
        match event {
            StreamEvent::MessageStart(event) => {
                self.message.role = event.role;
            }
            StreamEvent::ContentBlockStart(event) => {
                self.handle_content_block_start(event)?;
            }
            StreamEvent::ContentBlockDelta(event) => {
                self.handle_content_block_delta(event)?;
            }
            StreamEvent::ContentBlockStop(_) => {
                self.handle_content_block_stop()?;
            }
            StreamEvent::MessageStop(event) => {
                tracing::debug!("Streaming message completed with stop_reason: {:?}", event.stop_reason);
                self.is_complete = true;
                self.stop_reason = Some(event.stop_reason);
            }
            StreamEvent::Metadata(event) => {
                // Store token usage from metadata events
                self.token_usage = Some(event.usage);
            }
            StreamEvent::RedactContent(event) => {
                self.handle_redact_content(event)?;
            }
            // Error events don't directly affect message building
            StreamEvent::InternalServerException(_)
            | StreamEvent::ModelStreamErrorException(_)
            | StreamEvent::ServiceUnavailableException(_)
            | StreamEvent::ThrottlingException(_)
            | StreamEvent::ValidationException(_) => {}
        }
        Ok(())
    }

    fn handle_content_block_start(&mut self, event: ContentBlockStartEvent) -> Result<()> {
        match event.start {
            ContentBlockStart::Text => {
                // Starting a new text block
                self.current_text.clear();
            }
            ContentBlockStart::ToolUse { tool_use_id, name } => {
                // Starting a new tool use block
                self.current_tool_use = Some(CurrentToolUse {
                    tool_use_id,
                    name,
                    input: String::new(),
                });
            }
        }
        Ok(())
    }

    fn handle_content_block_delta(&mut self, event: ContentBlockDeltaEvent) -> Result<()> {
        match event.delta {
            ContentBlockDelta::Text(text_delta) => {
                self.current_text.push_str(&text_delta.text);
            }
            ContentBlockDelta::ToolUse(tool_delta) => {
                if let Some(ref mut tool_use) = self.current_tool_use {
                    tool_use.input.push_str(&tool_delta.input);
                }
            }
            ContentBlockDelta::ReasoningContent(reasoning_delta) => {
                if let Some(text) = reasoning_delta.text {
                    self.current_reasoning_text.push_str(&text);
                }
                if let Some(signature) = reasoning_delta.signature {
                    self.current_signature.push_str(&signature);
                }
            }
        }
        Ok(())
    }

    fn handle_content_block_stop(&mut self) -> Result<()> {
        // Finalize current content block
        if !self.current_text.is_empty() {
            self.message.content.push(ContentBlock::Text {
                text: self.current_text.clone(),
            });
            self.current_text.clear();
        }

        if let Some(tool_use) = self.current_tool_use.take() {
            // Parse the tool input JSON
            let input = serde_json::from_str(&tool_use.input)
                .unwrap_or_else(|_| serde_json::Value::Object(serde_json::Map::new()));

            self.message.content.push(ContentBlock::ToolUse {
                id: tool_use.tool_use_id,
                name: tool_use.name,
                input,
            });
        }

        if !self.current_reasoning_text.is_empty() {
            let signature = if self.current_signature.is_empty() {
                None
            } else {
                Some(self.current_signature.clone())
            };
            
            self.message.content.push(ContentBlock::reasoning_content(
                self.current_reasoning_text.clone(),
                signature,
            ));
            self.current_reasoning_text.clear();
            self.current_signature.clear();
        }

        Ok(())
    }

    fn handle_redact_content(&mut self, event: RedactContentEvent) -> Result<()> {
        if let Some(redacted_message) = event.redact_assistant_content_message {
            // Replace assistant content with redacted message
            self.message.content = vec![ContentBlock::Text {
                text: redacted_message,
            }];
        }
        Ok(())
    }

    /// Get the current message (may be incomplete)
    pub fn current_message(&self) -> &Message {
        &self.message
    }

    /// Check if the message is complete
    pub fn is_complete(&self) -> bool {
        self.is_complete
    }
    
    /// Get the stop reason if available
    pub fn stop_reason(&self) -> Option<&StopReason> {
        self.stop_reason.as_ref()
    }
    
    /// Get the token usage if available
    pub fn token_usage(&self) -> Option<&Usage> {
        self.token_usage.as_ref()
    }
}

/// Stream processor that converts AWS SDK streams to typed events
pub struct StreamProcessor {
    config: StreamConfig,
}

impl StreamProcessor {
    /// Create a new stream processor with the given configuration
    pub fn new(config: StreamConfig) -> Self {
        Self { config }
    }

    /// Process raw AWS SDK stream chunks into typed StreamEvents
    pub async fn process_aws_stream<S>(&self, _stream: S) -> Result<mpsc::Receiver<StreamEvent>>
    where
        S: Stream<Item = Result<bytes::Bytes>> + Send + 'static,
    {
        let (_tx, rx) = mpsc::channel(self.config.buffer_size);

        // Spawn task to process stream
        tokio::spawn(async move {
            // This method is a test utility - actual AWS streaming is implemented
            // in BedrockClient::chat_with_tools_streaming() and parse_aws_stream_event()
        });

        Ok(rx)
    }

    /// Create a test stream with sample events for testing
    pub async fn create_test_stream(&self) -> mpsc::Receiver<StreamEvent> {
        let (tx, rx) = mpsc::channel(self.config.buffer_size);

        tokio::spawn(async move {
            // Send sample events for testing
            let events = vec![
                StreamEvent::MessageStart(MessageStartEvent {
                    role: MessageRole::Assistant,
                }),
                StreamEvent::ContentBlockStart(ContentBlockStartEvent {
                    content_block_index: Some(0),
                    start: ContentBlockStart::Text,
                }),
                StreamEvent::ContentBlockDelta(ContentBlockDeltaEvent {
                    content_block_index: Some(0),
                    delta: ContentBlockDelta::Text(ContentBlockDeltaText {
                        text: "Hello".to_string(),
                    }),
                }),
                StreamEvent::ContentBlockDelta(ContentBlockDeltaEvent {
                    content_block_index: Some(0),
                    delta: ContentBlockDelta::Text(ContentBlockDeltaText {
                        text: " world!".to_string(),
                    }),
                }),
                StreamEvent::ContentBlockStop(ContentBlockStopEvent {
                    content_block_index: Some(0),
                }),
                StreamEvent::MessageStop(MessageStopEvent {
                    additional_model_response_fields: None,
                    stop_reason: StopReason::EndTurn,
                }),
                StreamEvent::Metadata(MetadataEvent {
                    metrics: Metrics { latency_ms: 1000 },
                    trace: None,
                    usage: Usage {
                        input_tokens: 10,
                        output_tokens: 5,
                        total_tokens: 15,
                    },
                }),
            ];

            for event in events {
                if tx.send(event).await.is_err() {
                    break;
                }
            }
        });

        rx
    }
}

/// Callback trait for handling streaming events in real-time
pub trait StreamCallback: Send + Sync {
    /// Called when a streaming event is received
    fn on_event(&self, event: &StreamEvent);

    /// Called when streaming starts
    fn on_start(&self) {}

    /// Called when streaming completes successfully
    fn on_complete(&self, _message: &Message, _usage: &Usage, _metrics: &Metrics) {}

    /// Called when streaming encounters an error
    fn on_error(&self, _error: &StoodError) {}
}

/// No-op callback for when no streaming callbacks are needed
pub struct NoOpCallback;

impl StreamCallback for NoOpCallback {
    fn on_event(&self, _event: &StreamEvent) {}
}

#[cfg(test)]
mod tests;

#[cfg(test)]
mod basic_tests {
    use super::*;

    #[test]
    fn test_stream_config_default() {
        let config = StreamConfig::default();
        assert!(config.enabled);
        assert_eq!(config.buffer_size, 100);
        assert!(config.enable_tool_streaming);
    }

    #[test]
    fn test_usage_default() {
        let usage = Usage::default();
        assert_eq!(usage.input_tokens, 0);
        assert_eq!(usage.output_tokens, 0);
        assert_eq!(usage.total_tokens, 0);
    }

    #[test]
    fn test_streaming_message_creation() {
        let message = StreamingMessage::new(MessageRole::Assistant);
        assert_eq!(message.message.role, MessageRole::Assistant);
        assert!(message.message.content.is_empty());
        assert!(!message.is_complete());
    }

    #[test]
    fn test_streaming_message_text_processing() {
        let mut message = StreamingMessage::new(MessageRole::Assistant);

        // Start message
        message
            .process_event(StreamEvent::MessageStart(MessageStartEvent {
                role: MessageRole::Assistant,
            }))
            .unwrap();

        // Start text block
        message
            .process_event(StreamEvent::ContentBlockStart(ContentBlockStartEvent {
                content_block_index: Some(0),
                start: ContentBlockStart::Text,
            }))
            .unwrap();

        // Add text deltas
        message
            .process_event(StreamEvent::ContentBlockDelta(ContentBlockDeltaEvent {
                content_block_index: Some(0),
                delta: ContentBlockDelta::Text(ContentBlockDeltaText {
                    text: "Hello".to_string(),
                }),
            }))
            .unwrap();

        message
            .process_event(StreamEvent::ContentBlockDelta(ContentBlockDeltaEvent {
                content_block_index: Some(0),
                delta: ContentBlockDelta::Text(ContentBlockDeltaText {
                    text: " world!".to_string(),
                }),
            }))
            .unwrap();

        // Stop text block
        message
            .process_event(StreamEvent::ContentBlockStop(ContentBlockStopEvent {
                content_block_index: Some(0),
            }))
            .unwrap();

        // Stop message
        message
            .process_event(StreamEvent::MessageStop(MessageStopEvent {
                additional_model_response_fields: None,
                stop_reason: StopReason::EndTurn,
            }))
            .unwrap();

        assert!(message.is_complete());
        assert_eq!(message.message.content.len(), 1);

        if let ContentBlock::Text { text } = &message.message.content[0] {
            assert_eq!(text, "Hello world!");
        } else {
            panic!("Expected text content block");
        }
    }

    #[test]
    fn test_streaming_message_tool_use_processing() {
        let mut message = StreamingMessage::new(MessageRole::Assistant);

        // Start tool use block
        message
            .process_event(StreamEvent::ContentBlockStart(ContentBlockStartEvent {
                content_block_index: Some(0),
                start: ContentBlockStart::ToolUse {
                    tool_use_id: "tool_123".to_string(),
                    name: "calculator".to_string(),
                },
            }))
            .unwrap();

        // Add tool input deltas
        message
            .process_event(StreamEvent::ContentBlockDelta(ContentBlockDeltaEvent {
                content_block_index: Some(0),
                delta: ContentBlockDelta::ToolUse(ContentBlockDeltaToolUse {
                    input: r#"{"expression": ""#.to_string(),
                }),
            }))
            .unwrap();

        message
            .process_event(StreamEvent::ContentBlockDelta(ContentBlockDeltaEvent {
                content_block_index: Some(0),
                delta: ContentBlockDelta::ToolUse(ContentBlockDeltaToolUse {
                    input: r#"2 + 2"}"#.to_string(),
                }),
            }))
            .unwrap();

        // Stop tool use block
        message
            .process_event(StreamEvent::ContentBlockStop(ContentBlockStopEvent {
                content_block_index: Some(0),
            }))
            .unwrap();

        assert_eq!(message.message.content.len(), 1);

        if let ContentBlock::ToolUse { id, name, input } = &message.message.content[0] {
            assert_eq!(id, "tool_123");
            assert_eq!(name, "calculator");
            assert_eq!(input["expression"], "2 + 2");
        } else {
            panic!("Expected tool use content block");
        }
    }

    #[tokio::test]
    async fn test_stream_processor_creation() {
        let config = StreamConfig::default();
        let processor = StreamProcessor::new(config);

        // Test creating a test stream
        let mut rx = processor.create_test_stream().await;

        let mut event_count = 0;
        while let Some(_event) = rx.recv().await {
            event_count += 1;
        }

        assert_eq!(event_count, 7); // Number of events in test stream
    }

    #[tokio::test]
    async fn test_streaming_message_with_test_stream() {
        let config = StreamConfig::default();
        let processor = StreamProcessor::new(config);
        let mut rx = processor.create_test_stream().await;

        let mut streaming_message = StreamingMessage::new(MessageRole::Assistant);

        while let Some(event) = rx.recv().await {
            streaming_message.process_event(event).unwrap();
        }

        assert!(streaming_message.is_complete());
        assert_eq!(streaming_message.message.content.len(), 1);

        if let ContentBlock::Text { text } = &streaming_message.message.content[0] {
            assert_eq!(text, "Hello world!");
        } else {
            panic!("Expected text content block");
        }
    }
}
